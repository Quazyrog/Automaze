#ifndef FINDANDUNION_HPP
#define FINDANDUNION_HPP

#include <unordered_map>
#include <vector>
#include "Exception.hpp"



/**
 * \brief Desjoint-set data structure implementation.
 * This class implements disjoint-set data structure. Sets are stored in array containing pairs of unsigned integers â€“ element's rank and it's parent index.
 * The class is used when fixing coherency of maze generated by cellular automaton's rules. It stores informations about disjoint sectors in the maze.
 */
class FindAndUnion
{
    /**
     * \brief Struct stroing informationa about initial set - its parent (representative) and it's rank.
     */
    struct Node 
    {
        /**
         * \brief Index of parent of given element.
         * The <c>parent</c> member stores index (in <c>FindAndUnion::data_</c> array) of parent of this initial set. If the set has no parent (poor set :( ), this will be set to 
         * index of given set. Every newly created set is an orphan.
         */
        unsigned int parent;
        
        /**
         * \brief Rank of given tis set's tree.
         * Used to speed up the structure. Equal to biggest depth this set's tree ever had.
         */
        unsigned int rank;
    };
    
    /**
     * \brief Array that stores data about all sets created in this structure. 
     * Array bstores all data used by structure. It is done mutable, because can be modified by representative (witch is const).
     */
    mutable std::vector<Node> data_;
    
public:
    /**
     * \brief Creates new set, disjoint with all others.
     * Creates new set with unique unmber (AUTO_INCREMENT, starting from 0) and appends it's data at end of <c>FindAndUnion::data_</c> array. Set will be disjoint 
     * with others (<c>parent = SET_NUMBER</c>).
     * \return Number of newly created set.
     */
    unsigned int newSet();
    
    /**
     * \brief Merge two sets into one.
     * This function merge set containing <c>a</c> with set containing <c>b</c>. If both are in the same set, nothing bad happens (but some parents may be changed as the function calls 
     * <c>FindAndUnion::representative</c>).
     * \throw IndexError when <c>a >= size()</c> or <c>b >= size()</c>
     */
    void merge(unsigned int a, unsigned int b);
    
    /**
     * \brief Returns root-parent of given element.
     * This function will return root of set (tree) in witch the <c>x</c> element is contained. This function will return tehe same value for two elements if and only if they
     * are in the same set.
     * \throw IndexError when <c>x >= size()</c>
     */
    unsigned int representative(unsigned int x) const;
    
    /**
     * \brief Number of elements stored in structure.
     * \return Number of elements stored in structure -- size() of <c>FindAndUnion::data</c>
     */
    unsigned int size() const noexcept {
        return data_.size();
    }
};

#endif
